;(_=>{
let hc={'<':'&lt;','&':'&amp;',"'":'&apos;','"':'&quot;'},he=x=>x.replace(/[<&'"]/g,c=>hc[c]) //html chars and escape fn
,tcs=''
,lbs=["○○\nread_byte\n push a single byte of unformatted input from STDIN (push sys.stdin.read(1))","◙◙\nwrite\n pop a: print a without a trailing newline","♂♂\nunary_map\n take the next command and map it over the top of the stack (for example, ♂A is equivalent to `A`M)","♀♀\nbinary_map\n take the next command and map it over the top 2 stack elements (like ♂ but for binary commands - ♀* is equivalent to Z`i*`M). If either of the top two stack elements are scalars (i.e. not iterables), it is reused for every element in the other iterable.","♫♫\nparallel_map\n take the next two commands and apply them each to the stack in parallel, and return the results as a list. If multiple values are output from a command, that output is nested in a list.","¶¶\niterate\n pop a: repeat the next command a times","§§\nread_all\n push all data from stdin as a string","▲▲\nlcm\n pop a,b: push lcm(a,b); pop [a]: push lcm([a])","▼▼\ngcd_reduce\n pop a,b: push b//gcd(a,b),a//gcd(a,b); pop [a]: push [x//gcd([a]) for x in [a]]","  \nstack_size\n push the # of elements on the stack (push len(stack))","!!\nfactorial\n pop a: push a! (factorial(a))","\"\"\nSYNTAX\n string literal, reads until next \" and pushes value onto stack. An implied \" is present at EOF if needed.","##\nlist\n pop a: push list(a)","$$\nstr\n pop a: push str(a)","%%\nmod\n pop a,b: push a%b; pop \"a\",[b]: push \"a\"%[b]","&&\nbitwise_and\n pop a,b: push (a & b)","''\nSYNTAX\n pushes next character onto stack as character literal (length-1 string)","((\nstack_rrot\n rotates stack right by 1","))\nstack_lrot\n rotates stack left by 1","**\nmultiply\n pop a,b: push a*b; pop \"a\",b: repeat \"a\" b times, push \"a\" (\"a\"*b); pop a,[b] or [b],a: apply a* to each element in the array; pop [a],[b]: push dot product of [a] and [b] (sum([a[i]*b[i] for i in len(a)])) (shorter is padded with 0s)","++\nadd concat\n pop a,b: push a+b; pop \"a\",\"b\": push concatenation of \"a\" and \"b\"; pop [a],[b]: push [a][b] (append [b] to [a]); pop a,[b] or [b],a: apply a+ to each element in the array",",,\nread_line\n read value from stdin and push","--\nsubtract asymmetric_difference\n pop a,b: push a-b; pop [a],[b] (or \"a\",[b] or [a],\"b\" or \"a\",\"b\"): push [a]-[b] (all elements of [a] not in [b])","..\nwrite_line write_fn\n pop a: write a to stdout; pop f: f. (call f and execute . recursively)","//\ndivide list_rrot\n pop a,b: push a/b (float division); pop [a]: rotate [a] right by 1, push [a]","00\nSYNTAX\n push 0","11\nSYNTAX\n push 1","22\nSYNTAX\n push 2","33\nSYNTAX\n push 3","44\nSYNTAX\n push 4","55\nSYNTAX\n push 5","66\nSYNTAX\n push 6","77\nSYNTAX\n push 7","88\nSYNTAX\n push 8","99\nSYNTAX\n push 9","::\nSYNTAX\n numeric literal delimiter: pushes the longest string of characters in '0123456789+-.ij' as a numeric",";;\ncopy\n pop a: push a,a (duplicates top element)","<<\nless_than\n pop a,b: push 1 if a<b else 0","==\nequal\n pop a,b: push 1 if a==b else 0",">>\ngreater_than\n pop a,b: push 1 if a>b else 0","??\nSYNTAX\n NOP, extended expressions if -e flag is passed","@@\nswap\n pop a,b: push a,b (rotate top 2 elements)","AA\nabs\n pop a: push abs(a)","BB\nbinary_randrange\n pop a,b: push a random integer in [a,b) (randrange(a,b))","CC\ncos\n pop a: push cos(a)","DD\ndecrement stddev\n pop a: push a-1; pop [a]: push stddev([a])","EE\nerf element\n pop a: push erf(a); pop [a],b: push [a][b] (bth item in [a]) (also works for strings)","FF\nfib first\n pop a: push Fib(a) (Fib(0)=0, Fib(1)=Fib(2)=1); pop [a]: push a[0]","GG\nrandom\n push a random float in the range [0,1) (push random())","HH\nhello_world head\n if stack is empty: push \"Hello, World!\"; pop \"a\" or [a],b: push a[:b]","II\nconditional\n pop a,b,c: push b if a is truthy, else push c","JJ\nunary_randrange random_choice\n pop a: push a random integer in [0,a) (randrange(a)); pop [a] or \"a\": push a random element from [a] or \"a\" (random.choice([a]|\"a\"))","KK\nceil\n pop a: push ceil(a)","LL\nfloor\n pop a: push floor(a)","MM\nmap max\n pop f,[a], execute f for each element in [a], using the element as a temporary stack, push [a] (similar to map(f,[a])); pop [a]: push max([a])","NN\nnnbb last\n if stack is empty: push the lyrics to \"99 Bottles of Beer\"; pop [a]: push a[-1]","OO\nord ords\n pop \"a\" or [a]: push [ord(c) for each c in \"a\" or [a], starting from the end]. If a list is popped, it is flattened, and if it contains strings of length > 1, the strings are exploded in-place (\"ABC\" -> [65,66,67], [\"A\",\"B\",\"CD\"] -> [65,66,67,68])","PP\nnth_prime\n pop a: push the a-th prime (zero-indexed)","QQ\nquine\n if stack is empty: push the program's source code","RR\nscoped_call reverse upper_range\n pop f,[a]: call f, using [a] as a temporary stack, push [a]; pop \"a\" or [a]: push reversed value (\"a\".reverse() or [a][::-1]); pop a: push [1,2,...,a] (range(1,a+1))","SS\nsin sort\n pop a: push sin(a); pop \"a\" or [a]: push sorted(a)","TT\ntangent set_element\n pop a: push tan(a); pop [a],b,c: set [a][b] to c, push [a]","UU\nunion\n pop [a],[b]: push union of [a] and [b]","VV\nrandom_uniform slices\n pop a,b: push uniform(a,b) (random float between a and b); pop \"a\" or [a],b: push all slices of a of length 1 <= n <= b","WW\nwhile_begin while_end\n loop delimiter: peek top of stack, repeat code in loop while a evaluates to true","XX\ndiscard\n pop a: discard","YY\nlogical_negate fixed_point\n pop a: push !bool(a) (logical negate, opposite of b); pop f: call f until there is no change from the last call (fixed-point combinator)","ZZ\nzip zip_n\n pop [a],[b]: push zip([a],[b]); pop a, zip the next a lists","[[\nSYNTAX\n begin list literal, values are delimited by commas (,)","\\\\\nfloor_divide list_lrot\n pop a,b: push a/b (integer division); pop [a]: rotate [a] left by 1, push [a]","]]\nSYNTAX\n end list literal","^^\nxor\n pop a,b: push a XOR b","__\nln\n pop a: push ln(a)","``\nSYNTAX\n prefix for function literal of length 1 (`p is the same as ⌠p⌡)","aa\nstack_invert\n invert the stack ([a,b,c,d] -> [d,c,b,a])","bb\nbool\n pop a: push 0 if a==0 else 1; pop \"a\" or [a]: push 0 if len(a)==0 else 1; pop f: push 0 if len(f)==0 else 1","cc\nchr count\n pop a: push character at ordinal a%256; pop [a],b: push [a].count(b); pop \"a\",\"b\": push \"a\".count(\"b\"); pop f, [a]: push the number of elements in [a] where f puts a truthy value on top of the stack","dd\ndequeue divmod\n pop [a]: dequeue b from [a], push [a],b; pop a,b: push divmod(a,b) (a//b, a%b)","ee\nexp\n pop a: push exp(a)","ff\nfib_index format\n pop a: push the Fibonacci index of a if a is a Fibonacci number, else -1; pop \"a\",[b]: push \"a\".format(*[b])","gg\ngcd\n pop a,b: push gcd(a,b); pop [a]: push gcd([a])","hh\nl2_norm\n pop a,b: push sqrt(a*a+b*b) (Euclidean norm)","ii\nfloat flatten\n pop \"a\": push atof(a); pop [a]: push each element from [a], starting from end (flatten)","jj\njoin\n pop \"a\",[b]: push \"a\".join([b]) (converting values in [b] to strings with $ if necessary)","kk\nnest_all\n pop all elements from stack, convert to list (in the order they were on the stack, starting from the top), and push","ll\nlen\n pop \"a\" or [a] or f: push len(a) (or len(f))","mm\nmodf min\n pop a: push int(a),frac(a) (modf(a)); pop [a]: push min([a])","nn\nrepeat_n iterate_n\n pop a,b: push a b times; pop f,b: call f b times","oo\nappend prime_factorization\n pop [a],b: push b to [a], push [a]; pop a: push the prime factorization of |a| with multiplicity (18 -> [2, 3, 3], -5 -> [5])","pp\nis_prime pop\n pop a: push 1 if a is prime else 0; pop [a]: pop b from [a], push [a],b","qq\nenqueue\n pop [a],b: enqueue b in [a], push [a]","rr\nlower_range\n pop a: push [0,1,...,a-1] (range(0,a)); pop \"a\" or [a] or f: push [0,1,...,len(a)-1] (range(0,len(a))) (or range(0,len(f)))","ss\nsgn split\n pop a: push sgn(a); pop [a],[b]: push a list of sublists of [a] split by any occurrences of elements of [b] (with \"a\", the sublists are strings)","tt\ntail translate\n pop \"a\" or [a],b: push a[b:]; pop \"a\",\"b\",\"c\": push a.translate(str.maketrans(b,c))","uu\nincrement\n pop a: push a+1","vv\nrandom_seed\n pop a: seed the RNG with a (random.seed(a))","ww\nprime_factors_exp\n pop a: push the full positive prime factorization of |a| (18 -> [[2,1],[3,2]], -5 -> [[5,1]])","xx\nbinary_range splat_range\n pop a,b: push [a,b) (range(a,b)); pop [a]: push range(*a)","yy\nprime_factors\n pop a: push the positive prime factors of |a| (18 -> [2,3], -5 -> [5])","zz\nwrite_many\n pop a: repeat . a times (pop a times and print to stdout)","{{\nstack_rrot_n\n pop a: rotate stack right a times","||\nbitwise_or\n pop a,b: push (a | b)","}}\nstack_lrot_n\n pop a: rotate stack left a times","~~\nbitwise_negate\n pop a: push ~a (unary bitwise negate)","⌂⌂\nexit\n terminate the program (without implicit stack popping and printing)","ÇÇ\ncomplex\n pop a,b: push a+bi; pop [a]: pop pairs of real numerics b,c from [a] and push b+ci (appending 0 to [a] if len([a]) is odd)","üü\nwrite_all\n pop entire stack and print to stdout","éé\ndiscard_all\n pop entire stack (clear stack)","ââ\nasin\n pop a: push asin(a)","ää\nacos\n pop a: push acos(a)","àà\natan\n pop a: push atan(a)","åå\natan2\n pop a,b: push atan2(a,b)","çç\nasinh\n pop a: push asinh(a)","êê\nacosh\n pop a: push acosh(a)","ëë\natanh\n pop a: push atanh(a)","èè\nrepr\n pop a: push repr(a)","ïï\nimag_unit\n push i, the imaginary unit (sqrt(-1) or 0+1i)","îî\nimag_mult\n pop a, push 0+ai; pop [a], push [a] with every element multiplied by i","ìì\ninverse numerics\n pop a: push 1/a; pop [a]: push numerics from [a]","ÄÄ\nsinh\n pop a: push sinh(a)","ÅÅ\ncosh\n pop a: push cosh(a)","ÉÉ\ntanh\n pop a: push tanh(a)","ææ\nmean\n pop [a]: push mean([a])","ÆÆ\nreplace strings\n pop \"a\",\"b\",\"c\": push \"a\".replace(\"b\",\"c\"); pop [a]: push strings from [a]","ôô\nstrip\n pop \"a\": push \"a\".strip()","öö\nlstrip\n pop \"a\": push \"a\".lstrip()","òò\nrstrip\n pop \"a\": push \"a\".rstrip()","ûû\nupper\n pop \"a\": push \"a\".upper()","ùù\nlower\n pop \"a\": push \"a\".lower()","ÿÿ\ntitle\n pop \"a\": push \"a\".title()","ÖÖ\nswapcase\n pop \"a\": push \"a\".swapcase()","ÜÜ\nmode\n pop [a]: push mode([a])","¢¢\ntake_sign\n pop a,b: push abs(a)*sgn(b)","££\nfunction functions\n pop \"a\": push a function whose code is \"a\"; pop [a]: push functions from [a]","¥¥\npair_add\n pop [a],[b]: push the result of pairwise addition of [a] and [b], padding the shorter with 0s","₧₧\nphase\n pop z: push phase(z)","ƒƒ\ncall\n pop f: call f","áá\ncomplex_conjugate\n pop z: push the complex conjugate of z","íí\nfind\n pop [a],b: push [a].index(b) (0-based, -1 if not found)","óó\nconditional_exit\n pop a: if bool(a) push a, else terminate the program (conditional exit); terminate the program if the stack is empty","úú\nalpha_lower\n push the lowercase English alphabet (ordinals 97-122)","ññ\nenumerate\n pop [a]: push enumerate([a]) ([[i,a[i]] for i in range(len(a))])","ÑÑ\nlists\n pop [a]: push lists from [a]","ºº\ndegrees\n pop a: push degrees(a)","¿¿\nint_base\n pop [a],b: push int([a],b) (interpret [a] as a base-b int)","⌐⌐\nadd_two\n pop a: push a+2","¬¬\nsubtract_two\n pop a: push a-2","½½\nhalf\n pop a: push a/2 (float division)","¼¼\nquarter\n pop a: push a/4 (float division)","¡¡\nstr_base\n pop a,b: push a string representing a in base b","««\nstack_insert_up\n pop a,b: insert b at position a, indexed from the bottom of the stack","»»\nstack_insert_down\n pop a,b: insert b at position a, indexed from the top of the stack","░░\nfilter\n pop [a],[b]: push [[b][i] if [a][i] for i in len(b)], pads [a] with 0s if necessary; pop f,[b]: push values of [b] where f returns a truthy value","▒▒\ntotient\n pop a: push totient(a) (# of integers <= a that are coprime with a)","▓▓\nprime_pi\n pop a: push pi(a) (# of primes <= a)","││\nstack_dup\n duplicate stack ([a,b,c] => [a,b,c,a,b,c])","┤┤\ncoprime\n pop a,b: push 1 if a and b are coprime else 0","╡╡\nchunk_number\n pop [a],b: push a list containing b non-overlapping sublists of [a] (chunk by number)","╢╢\nrindex\n pop [a] or \"a\", b: push a.rindex(b) (last index of b in a)","╖╖\nreg0_add\n pop a: add a to the value in register 0 (equivalent to ╜+╗)","╕╕\nreg1_add\n pop a: add a to the value in register 1 (equivalent to ╛+╝)","╣╣\npascal_row\n pop a: push the ath row in Pascal's triangle","║║\nmiddle\n pop [a] or \"a\": push median([a]/\"a\") (using ordinals if string)","╗╗\nreg0_save\n pop a: save a in register 0","╝╝\nreg1_save\n pop a: save a in register 1","╜╜\nreg0_load\n push the value in register 0 (initially a 0)","╛╛\nreg1_load\n push the value in register 1 (initially the empty string)","┐┐\nregn_save\n pop a,b: push b to register a","└└\nregn_load\n pop a: push the value in register a","┬┬\ntranspose\n pop a: push transpose(a) ([[1,2,3],[4,5,6]] -> [[1,4],[2,5],[3,6]])","├├\nbin\n pop a: push big-endian binary representation of a (bin(a) for ints, binary float data for floats, ascii_to_bin(a) for strings)","──\nhex\n pop a: push big-endian hexadecimal representation of a (same as 0xC3 but with hex)","┼┼\nstack_dup_each\n duplicate each element on stack ([a,b,c] => [a,a,b,b,c,c])","╞╞\nstack_dup_each_n\n pop a: make a total copies of each element on stack (3 [a,b,c] -> [a,a,a,b,b,b,c,c,c])","╟╟\nnest_n\n pop a: pop a elements and push a list containing those elements in their original order","╚╚\nshuffle\n pop [a]: push random.shuffle(a)","╔╔\nuniquify\n pop \"a\" or [a]: push uniquify(a)","╩╩\nreg_input\n read all input and push each to its own numbered register, starting with 0","╦╦\npi\n push pi","╠╠\ne\n push e","══\nis_unique\n pop \"a\" or [a], push 1 if all elements are unique else 0","╬╬\nwhile_call\n pop f: while value on top of stack is truthy (peek), call f","╧╧\ncombinations\n pop [a] or \"a\",b: push all b-length combinations of a","╨╨\npermutations\n pop [a] or \"a\",b: push all b-length permutations of a","╤╤\npow10\n pop a: push 10**a","╥╥\nlog10 log\n pop a: push log(a) (log base 10)","╙╙\npow2\n pop a: push 2**a","╘╘\nlog2 lg\n pop a: push lg(a) (log base 2)","╒╒\nln2\n push ln(2)","╓╓\nfirst_n_truthy\n pop f,n: push first n values where f(x) is truthy, starting with f(0) (the function is called each time with a stack only containing n)","╫╫\nre_im\n pop a: push Re(a), Im(a) (real and imaginary parts of a)","╪╪\nchunk_length\n pop [a],b: push a list containing each non-overlapping b-length sublist of [a] (chunk by length)","┘┘\nord_cp437\n pop a: push ord_cp437(a)","┌┌\nchr_cp437\n pop a: push chr_cp437(a)","██\nnCr\n pop a,b: push C(a,b) (aCb)","▄▄\nnPr\n pop a,b: push P(a,b) (aPb)","▌▌\nb64decode\n pop \"a\": push b64decode(\"a\")","▐▐\nb64encode\n pop \"a\": push b64encode(\"a\")","▀▀\nbase_digits\n pop a: push digits in base a","αα\nrepeat_each\n pop a,[b]: push a list containing all the elements of [b] repeated a times; pop a,b: push a list containing a copies of b","ßß\nnth_input\n pop a: push the ath input value (defaults to 0 if a is not an integer or is >= the number of inputs currently read (without consuming a), or if the stack is empty)","ΓΓ\ngamma\n pop a: push Gamma(a)","ππ\nproduct\n pop [a]: push product([a])","ΣΣ\nsum\n pop [a]: push sum([a])","σσ\ncumulative_sums\n pop [a]: push cumulative sums of [a]","µµ\nrms\n pop [a]: push rms (root-mean-square) of [a]","ττ\ndouble\n pop a: push 2*a","ΦΦ\nslice\n pop [a],b,c,d: push a[b:c:d]; pop [a],[b]: push a[b[0]:b[1]:b[2]] (list slicing)","δδ\ndig\n pop a: bring the (a mod len(stack))'th item on the stack to the top","∞∞\ntoggle_preserve preserve_on preserve_off\n toggle preserve mode; if on, stack items are peeked rather than popped; implicitly turned off at EOF","φφ\nphi\n push phi (golden ratio)","εε\nempty_string\n push \"\" (empty string)","∩∩\nintersection\n pop [a],[b]: push intersection of [a] and [b]","≡≡\neval\n pop a: push eval(a) (Python-style evaluation)","±±\nunary_negate swap_quotes\n pop a: push -a (unary negate); pop \"a\": push \"a\" with all single-quotes replaced with double quotes and vice-versa","≥≥\ngte\n pop a,b: push a>=b","≤≤\nlte\n pop a,b: push a<=b","⌠⌠\nfunc_begin\n begin function literal","⌡⌡\nfunc_end\n end function literal","÷÷\ndivisors\n pop a: push a list of all positive divisors of a that are less than or equal to a","≈≈\nint\n pop a: push int(a)","°°\nradians\n pop a: push radians(a)","∙∙\ncartesian_product cartesian_power\n pop [a],[b]: push Cartesian product of [a] and [b]; pop [a],b: push [a]^b (Cartesian product of b copies of [a])","√√\nsqrt\n pop a: push sqrt(a)","ⁿⁿ\npow\n pop a,b: push pow(a,b)","²²\nsquare\n pop a: push a*a","■■\nwrite_all_safe\n print the entire stack without popping, separated by spaces"]
,bqk=''.replace(/∙/g,'')
,bqv=''.replace(/∙/g,'')
,tc={},bqc={} //tab completions and ` completions
for(let i=0;i<bqk.length;i++)bqc[bqk[i]]=bqv[i]
for(let i=0;i<tcs.length;i+=3)tc[tcs[i]+tcs[i+1]]=tcs[i+2]
for(let i=0;i<tcs.length;i+=3){let k=tcs[i+1]+tcs[i];tc[k]=tc[k]||tcs[i+2]}
let lbh='';for(let i=0;i<lbs.length;i++){
  let ks=[]
  for(let j=0;j<tcs.length;j+=3)if(lbs[i][0]===tcs[j+2])ks.push('\n'+tcs[j]+' '+tcs[j+1]+' <tab>')
  for(let j=0;j<bqk.length;j++)if(lbs[i][0]===bqv[j])ks.push('\n` '+bqk[j])
  lbh+='<b title="'+he(lbs[i].slice(1))+(ks.length?'\n'+ks.join(''):'')+'">'+lbs[i][0]+'</b>'
}
let d=document,el=d.createElement('div');el.innerHTML=
`<div class=ngn_lb><span class=ngn_x title=Close>❎</span>${lbh}</div>
 <style>@font-face{font-family:"DVSM";src:local("DejaVu Sans Mono"),url(DejaVuSansMono.ttf)format('truetype');}</style>
 <style>
  .ngn_lb{position:fixed;top:0;left:0;right:0;background-color:#eee;color:#000;cursor:default;z-index:2147483647;
    font-family:"DVSM",monospace;border-bottom:solid #999 1px;padding:2px 2px 0 2px;word-wrap:break-word;}
  .ngn_lb b{cursor:pointer;padding:0 1px;font-weight:normal;display:inline-block}
  .ngn_lb b:hover,.ngn_bq .ngn_lb{background-color:#777;color:#fff}
  .ngn_x{float:right;color:#999;cursor:pointer;margin-top:-3px}
  .ngn_x:hover{color:#f00}
 </style>`
d.body.appendChild(el)
let t,ts=[],lb=el.firstChild,bqm=0 //t:textarea or input, lb:language bar, bqm:backquote mode
let pd=x=>x.preventDefault()
let ev=(x,t,f,c)=>x.addEventListener(t,f,c)
ev(lb,'mousedown',x=>{
  if(x.target.classList.contains('ngn_x')){lb.hidden=1;upd();pd(x);return}
  if(x.target.nodeName==='B'&&t){
    let i=t.selectionStart,j=t.selectionEnd,v=t.value,s=x.target.textContent
    if(i!=null&&j!=null){t.value=v.slice(0,i)+s+v.slice(j);t.selectionStart=t.selectionEnd=i+s.length}
    pd(x);return
  }
})
let fk=x=>{
  let t=x.target
  if(bqm){let i=t.selectionStart,v=t.value,c=bqc[x.key];if(x.which>31){bqm=0;d.body.classList.remove('ngn_bq')}
          if(c){t.value=v.slice(0,i)+c+v.slice(i);t.selectionStart=t.selectionEnd=i+1;pd(x);return!1}}
  switch(x.ctrlKey+2*x.shiftKey+4*x.altKey+8*x.metaKey+100*x.which){
    case   900:{let i=t.selectionStart,v=t.value,c=tc[v.slice(i-2,i)] //tab
                if(c){t.value=v.slice(0,i-2)+c+v.slice(i);t.selectionStart=t.selectionEnd=i-1;pd(x)}
                break}
  }
}
let ff=x=>{
  let t0=x.target,nn=t0.nodeName.toLowerCase()
  if(nn!=='textarea'&&(nn!=='input'||t0.type!=='text'&&t0.type!=='search'))return
  t=t0;if(!t.ngn){t.ngn=1;ts.push(t);ev(t,'keydown',fk)}
}
let upd=_=>{d.body.style.marginTop=lb.clientHeight+'px'}
upd();ev(window,'resize',upd)
ev(d,'focus',ff,!0);let ae=d.activeElement;ae&&ff({type:'focus',target:ae})
})();
