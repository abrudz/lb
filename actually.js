; (_ => {
	let hc = { '<': '&lt;', '&': '&amp;', "'": '&apos;', '"': '&quot;' }, he = x => x.replace(/[<&'"]/g, c => hc[c]) //html chars and escape fn
		, tcs = ''
		, lbs = ["○○\nread_byte\n push a single byte of unformatted input from STDIN (push sys.stdin.read(1))", "◙◙\nwrite\n pop a: print a without a trailing newline", "♂♂\nunary_map\n take the next command and map it over the top of the stack (for example, ♂A is equivalent to `A`M)", "♀♀\nbinary_map\n take the next command and map it over the top 2 stack elements (like ♂ but for binary commands - ♀* is equivalent to Z`i*`M). If either of the top two stack elements are scalars (i.e. not iterables), it is reused for every element in the other iterable.", "♫♫\nparallel_map\n take the next two commands and apply them each to the stack in parallel, and return the results as a list. If multiple values are output from a command, that output is nested in a list.", "¶¶\niterate\n pop a: repeat the next command a times", "§§\nread_all\n push all data from stdin as a string", "▲▲\nlcm\n pop a,b: push lcm(a,b); pop [a]: push lcm([a])", "▼▼\ngcd_reduce\n pop a,b: push b//gcd(a,b),a//gcd(a,b); pop [a]: push [x//gcd([a]) for x in [a]]", "  \nstack_size\n push the # of elements on the stack (push len(stack))", "!!\nfactorial\n pop a: push a! (factorial(a))", "\"\"\nSYNTAX\n string literal, reads until next \" and pushes value onto stack. An implied \" is present at EOF if needed.", "##\nlist\n pop a: push list(a)", "$$\nstr\n pop a: push str(a)", "%%\nmod\n pop a,b: push a%b; pop \"a\",[b]: push \"a\"%[b]", "&&\nbitwise_and\n pop a,b: push (a & b)", "''\nSYNTAX\n pushes next character onto stack as character literal (length-1 string)", "((\nstack_rrot\n rotates stack right by 1", "((\nstack_lrot\n: rotates stack left by 1", "**\nmultiply\n pop a,b: push a*b; pop \"a\",b: repeat \"a\" b times, push \"a\" (\"a\"*b); pop a,[b] or [b],a: apply a* to each element in the array; pop [a],[b]: push dot product of [a] and [b] (sum([a[i]*b[i] for i in len(a)])) (shorter is padded with 0s)", "++\nadd concat\n pop a,b: push a+b; pop \"a\",\"b\": push concatenation of \"a\" and \"b\"; pop [a],[b]: push [a][b] (append [b] to [a]); pop a,[b] or [b],a: apply a+ to each element in the array", ",,\nread_line\n read value from stdin and push", "--\nsubtract asymmetric_difference\n pop a,b: push a-b; pop [a],[b] (or \"a\",[b] or [a],\"b\" or \"a\",\"b\"): push [a]-[b] (all elements of [a] not in [b])", "..\nprint write_line write_fn\n pop a: write a to stdout; pop f: f. (call f and execute . recursively)", "//\ndivide list_rrot\n pop a,b: push a/b (float division); pop [a]: rotate [a] right by 1, push [a]", "00\nSYNTAX\n push 0", "11\nSYNTAX\n push 1", "22\nSYNTAX\n push 2", "33\nSYNTAX\n push 3", "44\nSYNTAX\n push 4", "55\nSYNTAX\n push 5", "66\nSYNTAX\n push 6", "77\nSYNTAX\n push 7", "88\nSYNTAX\n push 8", "99\nSYNTAX\n push 9", "::\nSYNTAX\n numeric literal delimiter: pushes the longest string of characters in '0123456789+-.ij' as a numeric", ";;\ncopy\n pop a: push a,a (duplicates top element)", "<<\nless_than\n pop a,b: push 1 if a<b else 0", "==\nequal\n pop a,b: push 1 if a==b else 0", ">>\ngreater_than\n pop a,b: push 1 if a>b else 0", "??\nSYNTAX\n NOP, extended expressions if -e flag is passed", "@@\nswap\n pop a,b: push a,b (rotate top 2 elements)", "AA\nabs\n pop a: push abs(a)", "BB\nbinary_randrange\n pop a,b: push a random integer in [a,b) (randrange(a,b))", "CC\ncos\n pop a: push cos(a)", "DD\ndecrement stddev\n pop a: push a-1; pop [a]: push stddev([a])", "EE\nerf element\n pop a: push erf(a); pop [a],b: push [a][b] (bth item in [a]) (also works for strings)", "FF\nfib first\n pop a: push Fib(a) (Fib(0)=0, Fib(1)=Fib(2)=1); pop [a]: push a[0]", "GG\nrandom\n push a random float in the range [0,1) (push random())", "HH\nhello_world head\n if stack is empty: push \"Hello, World!\"; pop \"a\" or [a],b: push a[:b]", "II\nconditional\n pop a,b,c: push b if a is truthy, else push c", "JJ\nunary_randrange random_choice\n pop a: push a random integer in [0,a) (randrange(a)); pop [a] or \"a\": push a random element from [a] or \"a\" (random.choice([a]|\"a\"))", "KK\nceil\n pop a: push ceil(a)", "LL\nfloor\n pop a: push floor(a)", "MM\nmap max\n pop f,[a], execute f for each element in [a], using the element as a temporary stack, push [a] (similar to map(f,[a])); pop [a]: push max([a])", "NN\nnnbb last\n if stack is empty: push the lyrics to \"99 Bottles of Beer\"; pop [a]: push a[-1]", "OO\nord ords\n pop \"a\" or [a]: push [ord(c) for each c in \"a\" or [a], starting from the end]. If a list is popped, it is flattened, and if it contains strings of length > 1, the strings are exploded in-place (\"ABC\" -> [65,66,67], [\"A\",\"B\",\"CD\"] -> [65,66,67,68])", "PP\nnth_prime\n pop a: push the a-th prime (zero-indexed)", "QQ\nquine\n if stack is empty: push the program's source code", "RR\nscoped_call reverse upper_range\n pop f,[a]: call f, using [a] as a temporary stack, push [a]; pop \"a\" or [a]: push reversed value (\"a\".reverse() or [a][::-1]); pop a: push [1,2,...,a] (range(1,a+1))", "SS\nsin sort\n pop a: push sin(a); pop \"a\" or [a]: push sorted(a)", "TT\ntangent set_element\n pop a: push tan(a); pop [a],b,c: set [a][b] to c, push [a]", "UU\nunion\n pop [a],[b]: push union of [a] and [b]", "VV\nrandom_uniform slices\n pop a,b: push uniform(a,b) (random float between a and b); pop \"a\" or [a],b: push all slices of a of length 1 <= n <= b", "WW\nwhile_begin while_end\n loop delimiter: peek top of stack, repeat code in loop while a evaluates to true", "XX\ndiscard\n pop a: discard", "YY\nlogical_negate fixed_point\n pop a: push !bool(a) (logical negate, opposite of b); pop f: call f until there is no change from the last call (fixed-point combinator)", "ZZ\nzip zip_n\n pop [a],[b]: push zip([a],[b]); pop a, zip the next a lists", "[[\nSYNTAX\n begin list literal, values are delimited by commas (,)", "\\\\\nfloor_divide list_lrot\n pop a,b: push a/b (integer division); pop [a]: rotate [a] left by 1, push [a]", "]]\nSYNTAX\n end list literal", "^^\nxor\n pop a,b: push a XOR b", "__\nln\n pop a: push ln(a); pop f, [a]: fold f over [a] (reduce)", "``\nSYNTAX\n prefix for function literal of length 1 (`p is the same as ⌠p⌡)", "aa\nstack_invert\n invert the stack ([a,b,c,d] -> [d,c,b,a])", "bb\nbool\n pop a: push 0 if a==0 else 1; pop \"a\" or [a]: push 0 if len(a)==0 else 1; pop f: push 0 if len(f)==0 else 1", "cc\nchr count\n pop a: push character at ordinal a%256; pop [a],b: push [a].count(b); pop \"a\",\"b\": push \"a\".count(\"b\"); pop f, [a]: push the number of elements in [a] where f puts a truthy value on top of the stack", "dd\ndequeue divmod\n pop [a]: dequeue b from [a], push [a],b; pop a,b: push divmod(a,b) (a//b, a%b)", "ee\nexp\n pop a: push exp(a)", "ff\nfib_index format\n pop a: push the Fibonacci index of a if a is a Fibonacci number, else -1; pop \"a\",[b]: push \"a\".format(*[b])", "gg\ngcd\n pop a,b: push gcd(a,b); pop [a]: push gcd([a])", "hh\nl2_norm\n pop a,b: push sqrt(a*a+b*b) (Euclidean norm)", "ii\nfloat flatten\n pop \"a\": push atof(a); pop [a]: push each element from [a], starting from end (flatten)", "jj\njoin\n pop \"a\",[b]: push \"a\".join([b]) (converting values in [b] to strings with $ if necessary)", "kk\nnest_all\n pop all elements from stack, convert to list (in the order they were on the stack, starting from the top), and push", "ll\nlen\n pop \"a\" or [a] or f: push len(a) (or len(f))", "mm\nmodf min\n pop a: push int(a),frac(a) (modf(a)); pop [a]: push min([a])", "nn\nrepeat_n iterate_n\n pop a,b: push a b times; pop f,b: call f b times", "oo\nappend prime_factorization\n pop [a],b: push b to [a], push [a]; pop a: push the prime factorization of |a| with multiplicity (18 -> [2, 3, 3], -5 -> [5])", "pp\nis_prime pop\n pop a: push 1 if a is prime else 0; pop [a]: pop b from [a], push [a],b", "qq\nenqueue\n pop [a],b: enqueue b in [a], push [a]", "rr\nlower_range\n pop a: push [0,1,...,a-1] (range(0,a)); pop \"a\" or [a] or f: push [0,1,...,len(a)-1] (range(0,len(a))) (or range(0,len(f)))", "ss\nsgn split\n pop a: push sgn(a); pop [a],[b]: push a list of sublists of [a] split by any occurrences of elements of [b] (with \"a\", the sublists are strings)", "tt\ntail translate\n pop \"a\" or [a],b: push a[b:]; pop \"a\",\"b\",\"c\": push a.translate(str.maketrans(b,c))", "uu\nincrement\n pop a: push a+1", "vv\nrandom_seed\n pop a: seed the RNG with a (random.seed(a))", "ww\nprime_factors_exp\n pop a: push the full positive prime factorization of |a| (18 -> [[2,1],[3,2]], -5 -> [[5,1]])", "xx\nbinary_range splat_range\n pop a,b: push [a,b) (range(a,b)); pop [a]: push range(*a)", "yy\nprime_factors\n pop a: push the positive prime factors of |a| (18 -> [2,3], -5 -> [5])", "zz\nwrite_many\n pop a: repeat . a times (pop a times and print to stdout)", "{{\nstack_rrot_n\n pop a: rotate stack right a times", "||\nbitwise_or\n pop a,b: push (a | b)", "}}\nstack_lrot_n\n pop a: rotate stack left a times", "~~\nbitwise_negate\n pop a: push ~a (unary bitwise negate)", "⌂⌂\nexit\n terminate the program (without implicit stack popping and printing)", "ÇÇ\ncomplex\n pop a,b: push a+bi; pop [a]: pop pairs of real numerics b,c from [a] and push b+ci (appending 0 to [a] if len([a]) is odd)", "üü\nwrite_all\n pop entire stack and print to stdout", "éé\ndiscard_all\n pop entire stack (clear stack)", "ââ\nasin\n pop a: push asin(a)", "ää\nacos\n pop a: push acos(a)", "àà\natan\n pop a: push atan(a)", "åå\natan2\n pop a,b: push atan2(a,b)", "çç\nasinh\n pop a: push asinh(a)", "êê\nacosh\n pop a: push acosh(a)", "ëë\natanh\n pop a: push atanh(a)", "èè\nrepr\n pop a: push repr(a)", "ïï\nimag_unit\n push i, the imaginary unit (sqrt(-1) or 0+1i)", "îî\nimag_mult\n pop a, push 0+ai; pop [a], push [a] with every element multiplied by i", "ìì\ninverse numerics\n pop a: push 1/a; pop [a]: push numerics from [a]", "ÄÄ\nsinh\n pop a: push sinh(a)", "ÅÅ\ncosh\n pop a: push cosh(a)", "ÉÉ\ntanh\n pop a: push tanh(a)", "ææ\nmean\n pop [a]: push mean([a])", "ÆÆ\nreplace strings\n pop \"a\",\"b\",\"c\": push \"a\".replace(\"b\",\"c\"); pop [a]: push strings from [a]", "ôô\nstrip\n pop \"a\": push \"a\".strip()", "öö\nlstrip\n pop \"a\": push \"a\".lstrip()", "òò\nrstrip\n pop \"a\": push \"a\".rstrip()", "ûû\nupper\n pop \"a\": push \"a\".upper()", "ùù\nlower\n pop \"a\": push \"a\".lower()", "ÿÿ\ntitle\n pop \"a\": push \"a\".title()", "ÖÖ\nswapcase\n pop \"a\": push \"a\".swapcase()", "ÜÜ\nmode\n pop [a]: push mode([a])", "¢¢\ntake_sign\n pop a,b: push abs(a)*sgn(b)", "££\nfunction functions\n pop \"a\": push a function whose code is \"a\"; pop [a]: push functions from [a]", "¥¥\npair_add\n pop [a],[b]: push the result of pairwise addition of [a] and [b], padding the shorter with 0s", "₧₧\nphase\n pop z: push phase(z)", "ƒƒ\ncall\n pop f: call f", "áá\ncomplex_conjugate\n pop z: push the complex conjugate of z", "íí\nfind\n pop [a],b: push [a].index(b) (0-based, -1 if not found)", "óó\nconditional_exit\n pop a: if bool(a) push a, else terminate the program (conditional exit); terminate the program if the stack is empty", "úú\nalpha_lower\n push the lowercase English alphabet (ordinals 97-122)", "ññ\nenumerate\n pop [a]: push enumerate([a]) ([[i,a[i]] for i in range(len(a))])", "ÑÑ\nlists\n pop [a]: push lists from [a]", "ºº\ndegrees\n pop a: push degrees(a)", "¿¿\nint_base\n pop [a],b: push int([a],b) (interpret [a] as a base-b int)", "⌐⌐\nadd_two\n pop a: push a+2", "¬¬\nsubtract_two\n pop a: push a-2", "½½\nhalf\n pop a: push a/2 (float division)", "¼¼\nquarter\n pop a: push a/4 (float division)", "¡¡\nstr_base\n pop a,b: push a string representing a in base b", "««\nstack_insert_up\n pop a,b: insert b at position a, indexed from the bottom of the stack", "»»\nstack_insert_down\n pop a,b: insert b at position a, indexed from the top of the stack", "░░\nfilter\n pop [a],[b]: push [[b][i] if [a][i] for i in len(b)], pads [a] with 0s if necessary; pop f,[b]: push values of [b] where f returns a truthy value", "▒▒\ntotient\n pop a: push totient(a) (# of integers <= a that are coprime with a)", "▓▓\nprime_pi\n pop a: push pi(a) (# of primes <= a)", "││\nstack_dup\n duplicate stack ([a,b,c] => [a,b,c,a,b,c])", "┤┤\ncoprime\n pop a,b: push 1 if a and b are coprime else 0", "╡╡\nchunk_number\n pop [a],b: push a list containing b non-overlapping sublists of [a] (chunk by number)", "╢╢\nrindex\n pop [a] or \"a\", b: push a.rindex(b) (last index of b in a)", "╖╖\nreg0_add\n pop a: add a to the value in register 0 (equivalent to ╜+╗)", "╕╕\nreg1_add\n pop a: add a to the value in register 1 (equivalent to ╛+╝)", "╣╣\npascal_row\n pop a: push the ath row in Pascal's triangle", "║║\nmiddle\n pop [a] or \"a\": push median([a]/\"a\") (using ordinals if string)", "╗╗\nreg0_save\n pop a: save a in register 0", "╝╝\nreg1_save\n pop a: save a in register 1", "╜╜\nreg0_load\n push the value in register 0 (initially a 0)", "╛╛\nreg1_load\n push the value in register 1 (initially the empty string)", "┐┐\nregn_save\n pop a,b: push b to register a", "└└\nregn_load\n pop a: push the value in register a", "┴┴\nSYNTAX\n pop f,[a]: push cumulative reduce of f over [a]", "┬┬\ntranspose\n pop a: push transpose(a) ([[1,2,3],[4,5,6]] -> [[1,4],[2,5],[3,6]])", "├├\nbin\n pop a: push big-endian binary representation of a (bin(a) for ints, binary float data for floats, ascii_to_bin(a) for strings)", "──\nhex\n pop a: push big-endian hexadecimal representation of a (same as 0xC3 but with hex)", "┼┼\nstack_dup_each\n duplicate each element on stack ([a,b,c] => [a,a,b,b,c,c])", "╞╞\nstack_dup_each_n\n pop a: make a total copies of each element on stack (3 [a,b,c] -> [a,a,a,b,b,b,c,c,c])", "╟╟\nnest_n\n pop a: pop a elements and push a list containing those elements in their original order", "╚╚\nshuffle\n pop [a]: push random.shuffle(a)", "╔╔\nuniquify\n pop \"a\" or [a]: push uniquify(a)", "╩╩\nreg_input\n read all input and push each to its own numbered register, starting with 0", "╦╦\npi\n push pi", "╠╠\ne\n push e", "══\nis_unique\n pop \"a\" or [a], push 1 if all elements are unique else 0", "╬╬\nwhile_call\n pop f: while value on top of stack is truthy (peek), call f", "╧╧\ncombinations\n pop [a] or \"a\",b: push all b-length combinations of a", "╨╨\npermutations\n pop [a] or \"a\",b: push all b-length permutations of a", "╤╤\npow10\n pop a: push 10**a", "╥╥\nlog10 log\n pop a: push log(a) (log base 10)", "╙╙\npow2\n pop a: push 2**a", "╘╘\nlog2 lg\n pop a: push lg(a) (log base 2)", "╒╒\nln2\n push ln(2)", "╓╓\nfirst_n_truthy\n pop f,n: push first n values where f(x) is truthy, starting with f(0) (the function is called each time with a stack only containing n)", "╫╫\nre_im\n pop a: push Re(a), Im(a) (real and imaginary parts of a)", "╪╪\nchunk_length\n pop [a],b: push a list containing each non-overlapping b-length sublist of [a] (chunk by length)", "┘┘\nord_cp437\n pop a: push ord_cp437(a)", "┌┌\nchr_cp437\n pop a: push chr_cp437(a)", "██\nnCr\n pop a,b: push C(a,b) (aCb)", "▄▄\nnPr\n pop a,b: push P(a,b) (aPb)", "▌▌\nb64decode\n pop \"a\": push b64decode(\"a\")", "▐▐\nb64encode\n pop \"a\": push b64encode(\"a\")", "▀▀\nbase_digits\n pop a: push digits in base a", "αα\nrepeat_each\n pop a,[b]: push a list containing all the elements of [b] repeated a times; pop a,b: push a list containing a copies of b", "ßß\nnth_input\n pop a: push the ath input value (defaults to 0 if a is not an integer or is >= the number of inputs currently read (without consuming a), or if the stack is empty)", "ΓΓ\ngamma\n pop a: push Gamma(a)", "ππ\nproduct\n pop [a]: push product([a])", "ΣΣ\nsum\n pop [a]: push sum([a])", "σσ\ncumulative_sums\n pop [a]: push cumulative sums of [a]", "µµ\nrms\n pop [a]: push rms (root-mean-square) of [a]", "ττ\ndouble\n pop a: push 2*a", "ΦΦ\nslice\n pop [a],b,c,d: push a[b:c:d]; pop [a],[b]: push a[b[0]:b[1]:b[2]] (list slicing)", "δδ\ndig\n pop a: bring the (a mod len(stack))'th item on the stack to the top", "∞∞\ntoggle_preserve preserve_on preserve_off\n toggle preserve mode; if on, stack items are peeked rather than popped; implicitly turned off at EOF", "φφ\nphi\n push phi (golden ratio)", "εε\nempty_string\n push \"\" (empty string)", "∩∩\nintersection\n pop [a],[b]: push intersection of [a] and [b]", "≡≡\neval\n pop a: push eval(a) (Python-style evaluation)", "±±\nunary_negate swap_quotes\n pop a: push -a (unary negate); pop \"a\": push \"a\" with all single-quotes replaced with double quotes and vice-versa", "≥≥\ngte\n pop a,b: push a>=b", "≤≤\nlte\n pop a,b: push a<=b", "⌠⌠\nfunc_begin\n begin function literal", "⌡⌡\nfunc_end\n end function literal", "÷÷\ndivisors\n pop a: push a list of all positive divisors of a that are less than or equal to a", "≈≈\nint\n pop a: push int(a)", "°°\nradians\n pop a: push radians(a)", "∙∙\ncartesian_product cartesian_power\n pop [a],[b]: push Cartesian product of [a] and [b]; pop [a],b: push [a]^b (Cartesian product of b copies of [a])", "√√\nsqrt\n pop a: push sqrt(a)", "ⁿⁿ\npow\n pop a,b: push pow(a,b)", "²²\nsquare\n pop a: push a*a", "■■\nwrite_all_safe\n print the entire stack without popping, separated by spaces"]
		, bqk = ''.replace(/∙/g, '')
		, bqv = ''.replace(/∙/g, '')
		, tc = {}, bqc = {} //tab completions and ` completions
	for (let i = 0; i < bqk.length; i++)bqc[bqk[i]] = bqv[i]
	for (let i = 0; i < tcs.length; i += 3)tc[tcs[i] + tcs[i + 1]] = tcs[i + 2]
	for (let i = 0; i < tcs.length; i += 3) { let k = tcs[i + 1] + tcs[i]; tc[k] = tc[k] || tcs[i + 2] }
	let lbh = ''; for (let i = 0; i < lbs.length; i++) {
		let ks = []
		for (let j = 0; j < tcs.length; j += 3)if (lbs[i][0] === tcs[j + 2]) ks.push('\n' + tcs[j] + ' ' + tcs[j + 1] + ' <tab>')
		for (let j = 0; j < bqk.length; j++)if (lbs[i][0] === bqv[j]) ks.push('\n` ' + bqk[j])
		lbh += '<b title="' + he(lbs[i].slice(1) + (ks.length ? '\n' + ks.join('') : '')) + '">' + lbs[i][0] + '</b>'
	}
	let d = document, el = d.createElement('div'); el.innerHTML =
		`<div class=ngn_lb><span class=ngn_x title=Close>❎</span>${lbh}</div>
 <style>@font-face{font-family:"DVSM";src:local("DejaVu Sans Mono"),url(//abrudz.github.io/lb/DejaVuBQNSansMono.ttf)format('truetype');}</style>
 <style>
  .ngn_lb{position:fixed;top:0;left:0;right:0;background-color:#eee;color:#000;cursor:default;z-index:2147483647;
    font-family:"DVSM",monospace;border-bottom:solid #999 1px;padding:2px 2px 0 2px;word-wrap:break-word;}
  .ngn_lb b{cursor:pointer;padding:0 1px;font-weight:normal;display:inline-block}
  .ngn_lb b:hover,.ngn_bq .ngn_lb{background-color:#777;color:#fff}
  .ngn_x{float:right;color:#999;cursor:pointer;margin-top:-3px}
  .ngn_x:hover{color:#f00}
 </style>`
	d.body.appendChild(el)
	let t, ts = [], lb = el.firstChild, bqm = 0 //t:textarea or input, lb:language bar, bqm:backquote mode
	let pd = x => x.preventDefault()
	let ev = (x, t, f, c) => x.addEventListener(t, f, c)
	ev(lb, 'mousedown', x => {
		if (x.target.classList.contains('ngn_x')) { lb.hidden = 1; upd(); pd(x); return }
		if (x.target.nodeName === 'B' && t) {
			let i = t.selectionStart, j = t.selectionEnd, v = t.value, s = x.target.textContent
			if (i != null && j != null) { t.value = v.slice(0, i) + s + v.slice(j); t.selectionStart = t.selectionEnd = i + s.length }
			pd(x); return
		}
	})
	let fk = x => {
		let t = x.target
		if (bqm) {
			let i = t.selectionStart, v = t.value, c = bqc[x.key]; if (x.which > 31) { bqm = 0; d.body.classList.remove('ngn_bq') }
			if (c) { t.value = v.slice(0, i) + c + v.slice(i); t.selectionStart = t.selectionEnd = i + 1; pd(x); return !1 }
		}
		switch (x.ctrlKey + 2 * x.shiftKey + 4 * x.altKey + 8 * x.metaKey + 100 * x.which) {
			case 900: {
				let i = t.selectionStart, v = t.value, c = tc[v.slice(i - 2, i)] //tab
				if (c) { t.value = v.slice(0, i - 2) + c + v.slice(i); t.selectionStart = t.selectionEnd = i - 1; pd(x) }
				break
			}
		}
	}
	let ff = x => {
		let t0 = x.target, nn = t0.nodeName.toLowerCase()
		if (nn !== 'textarea' && (nn !== 'input' || t0.type !== 'text' && t0.type !== 'search')) return
		t = t0; if (!t.ngn) { t.ngn = 1; ts.push(t); ev(t, 'keydown', fk) }
	}
	let upd = _ => { d.body.style.marginTop = lb.clientHeight + 'px' }
	upd(); ev(window, 'resize', upd)
	ev(d, 'focus', ff, !0); let ae = d.activeElement; ae && ff({ type: 'focus', target: ae })
})();
