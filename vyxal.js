; (_ => {
	let hc = { '<': '&lt;', '&': '&amp;', "'": '&apos;', '"': '&quot;' }, he = x => x.replace(/[<&'"]/g, c => hc[c]) //html chars and escape fn
		, tcs = "A\\λ`lλAxƛ`Lƛ-,¬or∨:-÷-:÷xx×<<«>>»^o°..•ssßtt†CE€EC€C=€=C€^_∆o/ø<>↔lr↔c|¢,-⌐aeæRRʀ_RʀR_ʁR'ʁrrɾ,rɽrhɽbpÞchƈoo∞^^¨^:¨up↑^|↑dn↓:.∴.:∵_>›_<‹::∷[]¤dxð->→<-←BBβ.aȧ.bḃ.cċ.dḋ.eė.fḟ.gġ.hḣi~ḭl.ŀ.lŀ.mṁ.nṅ.oȯ.pṗ.rṙ.sṡ.tṫ.wẇ.xẋ.yẏ.zżv/√[[⟨]]⟩\\'‛``‛_0₀_1₁_2₂_3₃_4₄_5₅_6₆_7₇_8₈pp⁋SS§eeε!!¡EE∑||¦~~≈~=≈|uµmuµ.AȦ.BḂ.CĊ.DḊ.EĖ.FḞ.GĠ.HḢ.Iİ.LĿL.Ŀ.MṀ.NṄ.OȮ.PṖ.RṘ.SṠ.TṪ.WẆ.XẊ.YẎ.ZŻ_=₌_(₍^0⁰^1¹^2²_v∇|^⌈|_⌊^-¯+-±pm±S=₴el…L>↳v>↳<|↲<v↲/\\꘍vc꘍^!ꜝco℅<=≤le≤>=≥ge≥!=≠ne≠^=⁼fhƒf/ƒffƒdqɖUU∪nn∩u.⊍LE£Y=¥=Y¥UP⇧DN⇩uAǍvAǍuaǎvaǎuIǏvIǏuiǐviǐuOǑvOǑuoǒvoǒuUǓvUǓvuǔuuǔ^(⁽|=‡=|‡++‡()≬^+⁺qt¼3q¾piΠ,,„''‟"
	        , lbs = ["λλ\n* lambda: λ...; λarity|...;  (Function definition)","ƛƛ\n* lambda map: ƛ...;  (Map a series of functions over top of stack)","¬¬\nnot a (non-vectorising)","∧∧\na and b (non-vectorising)","⟑⟑\nb and a (non-vectorising)","∨∨\na or b (non-vectorising)","⟇⟇\nb or a (non-vectorising)","÷÷\nstack += iterable(a)","××\n\"*\"","««\n* base_255 compressed string: «...«","»»\n* base_255 compressed number: »...»","°°\n* function reference: °defined_function_name;","••\nlog_a(b)\n[char * a for char in b]\n[char * b for char in a]\na.with_capitalisation_of(b)\na molded to the shape of b\nvectorised","ßß\n* execute next element if a is truthy: ß<element>","††\n* call function reference\nexec(a)\nlen(prime_factors(a))\nvectorised not a, ¬ vectorised","€€\na.split_on(b)","½½\na / 2\na split into two strings of equal lengths (as close as possible)\nvectorised","∆∆\n* mathematic digraphs (see near the end of docs)","øø\n* string digraphs (see near the end of docs)","↔↔\ncombinations_with_replacement(a, length=b)\nremove elements in a that are not in b\napply a on b until the result does not change. Collects intermittent values","¢¢\nreplace b in a with c until a does not change","⌐⌐\n1 - a\na.split(\",\")\nvectorised","ææ\nis_prime(a)\ncase_of(a)\nvectorised","ʀʀ\nrange(0, a + 1)\nstr(a) == \"0\"","ʁʁ\nrange(0, a)\nstr(a) == \"0\"","ɾɾ\nrange(1, a + 1)\nstr(a) == \"1\"","ɽɽ\nrange(1, a)\nstr(a) == \"1\"","ÞÞ\n* list digraphs (see near the end of docs)","ƈƈ\na choose b (n choose r, ncr, n c r), Binomial Coefficient\n[random.choice(b) for _ in range(a)]\n[random.choice(a) for _ in range(b)]\nset(a) == set(b)\nvectorised","∞∞\nlist of all non-negative integers, starting at 0","¨¨\n* other digraphs (see near the end of docs)","!!\nlength(stack)","\"\"\n[a, b]","##\n* comment","$$\nb, a","%%\na % b\n(b split into a equal pieces)[-1]\n(a split into b equal pieces)[-1]\na.format(b)\na.format(b)\nvectorised","&&\n* apply next element to register: &<element>","''\n* lambda filter, map or apply a series of functions over top of stack, and filter out the truthy ones","((\n* open for loop: (variable|...)","))\n* close for loop","**\na * b\nb repeated a times\na repeated b times\n[char + b for char in a]\nvectorised","++\na + b\nconcat(a, b)\nconcat(a, b)\nconcat(a, b)\nvectorised",",,\nprint(a)","--\na - b\n(\"-\" * a) + b\na + (\"-\" * b)\na.remove(b)\nvectorised","..\n* decimal seperator","//\na / b\nb split into a even length pieces. There may be an extra part if the string is too long.\na split into b even length pieces. There may be an extra part if the string is too long.\na.split(b)\nvectorised","00\n* numeric literal","11\n* numeric literal","22\n* numeric literal","33\n* numeric literal","44\n* numeric literal","55\n* numeric literal","66\n* numeric literal","77\n* numeric literal","88\n* numeric literal","99\n* numeric literal","::\na, a",";;\n* closes a structure","<<\na < b\nvectorised","==\na == b\na == b",">>\na > b\nvectorised","??\ninput()","@@\n* define a function: @name:parameters|...;\n* call a function: @name;","AA\nall(a)","BB\nint(a, 2)\nint(a, 2)","CC\nchr(a)\nord(a) if len(a) == 1 else [ord(char) for char in a]\nvectorised","DD\na, a, a","EE\n2 ** a\neval(a)\nvectorised","FF\nfilter(b, a)\nremove elements of a that are in b","GG\nmax(a)","HH\nint(a, 16)\nint(a, 16)","II\nint(a)\nint(a)\nint(a)","JJ\na.append(b)\nb.prepend(a)\nmerged(a, b)\nconcatenated(a, b)","KK\ndivisors(a)\nall substrings of a that occur more than once\nprefixes(a)","LL\nlen(a)","MM\nmap(b, a)\n[[a, item] for item in b]","NN\n-a\nswap_case(a)\nvectorised","OO\na.count(b)","PP\na.strip(b)","QQ\nexit()","RR\nreduce a by b\na, vectorised_reverse(b)","SS\nstr(a)","TT\ntruthy indices in a","UU\nuniquifed(a)","VV\na.replace(needle=b, replacement=c)","WW\n[stack]","XX","YY\ninterleave(a, b)","ZZ\nzip(a, b)","[[\n* open if statement: [truthy|falsey]","\\\\\n* one character literal: \\<letter>, Capture the next element as a string","]]\n* close if statement","``\n* string literal: `...`","^^\n* reverse stack","__\ndiscard/pop/remove item","aa\nany(a)","bb\nbin(a)\n[bin(ord(char)) for char in a]\nvectorised","cc\nb in a","dd\na * 2\na * 2\nvectorised","ee\na ** b\nevery ath letter of b\nevery bth letter of a\nregex.search(pattern=a, string=b).span()\nvectorised","ff\nlist of digits of a\nlist of characters of a\nflattened(a)","gg\nmin(a)","hh\na[0]","ii\na[b]\na[:b]\na[x:y]\na[x:y:m]","jj\na.join(b)","kk\n* constant digraphs (see near the end of docs)","ll\nn-wise_group(a, b)\nlength(a) == length(b)","mm\na + reversed(a)","nn\n* context variable","oo\na.replace(b, \"\")","pp\nprepend a to b","qq\n\"`\" + a + \"`\"","rr\nrange(a, b)\ncumulative_reduce(a, function=b)\nregex.has_match(pattern=a, string=b)","ss\nsorted(a)","tt\na[-1]","uu\n-1","vv\n* vectorise next element: v<element>, apply next element to each item in top of stack","ww\n[a]","xx\n* call current function","yy\nuninterleave(a)","zz\nzip(a, map(b, a))\na, zip(b, b)","{{\n* open while loop: {condition|...}","||\n* branch in structure (syntax), Used to seperate blocks in If/For/While/Lambda/Function definition","}}\n* close while loop","~~\n* filter by element (monad)\n* execute element without popping (dyad)","↑↑\nmax(a, key=lambda x: x[-1])","↓↓\nmin(a, key=lambda x: x[-1])","∴∴\nmax(a, b)","∵∵\nmin(a, b)","››\na + 1\nconcat(a, \"1\")\nvectorised","‹‹\na - 1\na + \"-\"\nvectorised","∷∷\na % 2\nlast half of a\nvectorised","¤¤\n\"\"","ðð\n\" \"","→→\n* variable set (= a): →name","←←\n* variable get: ←name","ββ\na to base 10 from arbitrary base b\na to base 10 from custom base b","ττ\na from base 10 to arbitrary base b\na from base 10 to custom base b\na from base 10 to custom base b","ȧȧ\nabs(a)\nremove whitespace from a\nvectorised","ḃḃ\nbool(a)","ċċ\na != 1","ḋḋ\n[a / b, a % b]\ncombinations of a with length b\ncombinations of a with length b\na.trim(b)","ėė\nenumerate(a)","ḟḟ\na.find(b)\ntruthy_indices(map(b, a))","ġġ\ngcd(a)\ngcd(a, b)\nlongest common suffix(a, str(b))","ḣḣ\na[0], a[1:]","ḭḭ\na // b\n(b / a)[0]\n(a / b)[0]\n* right reduce b by a\n* right reduce a by b","ŀŀ\na.find(b, start=c)","ṁṁ\narithmetic_mean(a)","ṅṅ\nfirst integer where a(x) is truthy\n\"\".join(a)","ȯȯ\nfirst n integers where a(x) is truthy\na[b:]","ṗṗ\npowerset(a)","ṙṙ\nround(a)","ṡṡ\nsorted(a, key=b)\nrange(a, b + 1)\nregex.split(string=a, pattern=str(b))\nregex.split(string=str(a), pattern=b)","ṫṫ\na[:-1], a[-1]","ẇẇ\na wrapped in chunks of length b\napply b to every second item of a\napply a to every second item of b","ẋẋ\nrepeat(a, times=b)\ncollect_until_false(predicate=a, modifying_function=b, inital=c)","ẏẏ\nrange(0, len(a))","żż\nrange(1, len(a) + 1)","√√\nsqrt(a)\nevery second character of a\nvectorised","⟨⟨\n* open a list: ⟨...⟩","⟩⟩\n* close a list","‛‛\n* two character string literal: ‛..","₀₀\n10","₁₁\n100","₂₂\na % 2 == 0\nlen(a) % 2 == 0","₃₃\na % 3 == 0\nlen(a) == 1","₄₄\n26","₅₅\na % 5 == 0\na, len(a)","₆₆\n64","₇₇\n128","₈₈\n256","¶¶\n\"\\n\"","⁋⁋\n\"\\n\".join(a)","§§\nvertical_join(a)","εε\nvertical_join(a, padding=b)\nabs(a - b)","¡¡\nfactorial(a)\nsentence_case(a)\nvectorised","∑∑\nsum(a)","¦¦\ncumulative_sum(a)\nprefixes of a","≈≈\nare all elements the same?","µµ\n* lambda sort: µ...;. The same as λ...;ṡ","ȦȦ\na[b] = c","ḂḂ\na, reversed(a)","ĊĊ\ncounts_of_items(a)","ḊḊ\na % b == 0\nb copies of a\nlen(b) copies of a\na copies of b\nvectorised","ĖĖ\nVyxal_exec(a)\n1 / a\nvectorise","ḞḞ\npush Generator of function f with initial vector a\npush Generator of function f with intial vector a, limited to b items (if present)","ĠĠ\ngroup_consecutive(a)","ḢḢ\na[1:]","İİ\n[a[item] for item in b]\nrepeat funciton b on a while the function results are not-unique","ĿĿ\ntransliterate(a, b, c)\nrepeat_until_false(predicate=a, modifying_function=b, inital=c)","ṀṀ\na.insert(b, c)\nc mapped over every bth item of a","ṄṄ\ninteger_paritions(a)\n\" \".join(a)","ȮȮ\nstack[-2]","ṖṖ\npermutations(a)","ṘṘ\nreversed(a)","ṠṠ\nsum(stack)","ṪṪ\na[:-1]","ẆẆ\na.split_and_keep_delimiter(b)","ẊẊ\ncartesian_product(a, b)\nrepeatedly apply a on b until b does not change","ẎẎ\na[0:b]\nregex.findall(pattern=a, string=b)","ŻŻ\na[1:b]\nregex.match(pattern=a, string=b).groups()","₌₌\n* parallel apply next two elements: ₌<element><element>","₍₍\n* parallel apply next two elements and put into list: ₍<element><element>. Equivalent to ₌..\"","⁰⁰\nfirst item from input history","¹¹\nsecond item from input history","²²\na ** 2\na formatted as a square\nvectorised","∇∇\nc, a, b","⌈⌈\nceiling(a)\na.split(\" \")","⌊⌊\nfloor(a)\nint(keep only digits of a)","¯¯\ndeltas(a)","±±\nsign_of(a)\n-1, 0 = 0, positive = 1, signum\na\nvectorised","₴₴\nprint(a, end=\"\")","……\nprint(stack[-1])","□□\nall inputs wrapped in a list","↳↳\na >> b\na.rjust(b)\nb.rjust(a)\na.rjust(len(b) - len(a))\nvectorised","↲↲\na << b\na.ljust(b)\nb.ljust(a)\na.ljust(len(b) - len(a))\nvectorised","⋏⋏\na and b (bitwise)\na.center(b)\nb.center(a)\na.center(len(b) - len(a))\nvectorised","⋎⋎\na or b (bitwise)\nremove bth character of a\nremove ath character of b\na and b joined on longest common prefix and suffix\nvectorised","꘍꘍\na xor b (bitwise)\na + \" \" * b\n\" \" * a + b\nlevenshtein_distance(a, b)\nvectorised","ꜝꜝ\nnot a (bitwise)\nare any letters in a uppercase?\nvectorised","℅℅\nrandom.choice(a)","≤≤\na <= b","≥≥\na >= b","≠≠\na != b (non-vectorising)","⁼⁼\na == b (non-vectorising)","ƒƒ\nfractionify(a)\nfractionify(a) if a is numeric string","ɖɖ\ndecimalify(a)","∪∪\nset union","∩∩\nset intersection","⊍⊍\nset(a) ^ set(b)","££\nset register without emptying","¥¥\npush register without emptying","⇧⇧\ngraded_up(a)\na.upper()\na + 2","⇩⇩\ngraded_down(a)\na.lower()\na - 2","ǍǍ\nremove all non-letters of a `^[A-Za-z]`\n2 ** a\nvectorised","ǎǎ\npush ath prime\nsubstrings(a)\nvectorised","ǏǏ\nprime factorisation of a\t\na + a[0]\nvectorised","ǐǐ\nall prime factors of a (includes duplicates)\na.titlecase()\nvectorised","ǑǑ\nhow many times does b divide a?\nremove b from a until a does not change","ǒǒ\na % 3\nis string empty?\nvectorised","ǓǓ\nrotate a b units to the left\na, b rotated to the left once","ǔǔ\nrotate a b units to the right\na, b rotated to the right once","⁽⁽\n* one-byte lambda: ⁽<element>","‡‡\n* two-byte lambda: ‡<element><element>","≬≬\n* three-byte lambda: ≬<element><element><element>","⁺⁺\n* index of next character in codepage + 101: ⁺<character>","↵↵\na.split(\"\\n\")\n10 ** a\nvectorised","⅛⅛\npush a to global array, but not pop a","¼¼\npop from global array and push to stack","¾¾\npush global array","ΠΠ\nproduct(a)","„„\n* rotate stack left","‟‟\n* rotate stack right"," ","kk\nconstants","∆∆\nmath functions","øø\nString functions","ÞÞ\nMisc. functions","¨¨\nMisc. functions"]
	        , bqk = ''.replace(/∙/g, '')
		, bqv = ''.replace(/∙/g, '')
		, tc = {}, bqc = {} //tab completions and ` completions
	for (let i = 0; i < bqk.length; i++)bqc[bqk[i]] = bqv[i]
	for (let i = 0; i < tcs.length; i += 3)tc[tcs[i] + tcs[i + 1]] = tcs[i + 2]
	for (let i = 0; i < tcs.length; i += 3) { let k = tcs[i + 1] + tcs[i]; tc[k] = tc[k] || tcs[i + 2] }
	let lbh = ''; for (let i = 0; i < lbs.length; i++) {
		let ks = []
		for (let j = 0; j < tcs.length; j += 3)if (lbs[i][0] === tcs[j + 2]) ks.push('\n' + tcs[j] + tcs[j + 1] + ' <tab>')
		for (let j = 0; j < bqk.length; j++)if (lbs[i][0] === bqv[j]) ks.push('\n` ' + bqk[j])
		lbh += '<b title="' + he(lbs[i].slice(1) + (ks.length ? '\n' + ks.join('') : '')) + '">' + lbs[i][0] + '</b>'
	}
	let d = document, el = d.createElement('div'); el.innerHTML =
		`<div class=ngn_lb><span class=ngn_x title=Close>❎</span>${lbh}</div>
 <style>@font-face{font-family:"DVSM";src:local("DejaVu Sans Mono"),url(//abrudz.github.io/lb/DejaVuBQNSansMono.ttf)format('truetype');}</style>
 <style>
  .ngn_lb{position:fixed;top:0;left:0;right:0;background-color:#eee;color:#000;cursor:default;z-index:2147483647;
    font-family:"DVSM",monospace;border-bottom:solid #999 1px;padding:2px 2px 2px 2px;word-wrap:break-word;}
  .ngn_lb b{cursor:pointer;padding:0 1px;font-weight:normal;display:inline-block}
  .ngn_lb b:hover,.ngn_bq .ngn_lb{background-color:#777;color:#fff}
  .ngn_x{float:right;color:#999;cursor:pointer;margin-top:-3px}
  .ngn_x:hover{color:#f00}
 </style>`
	d.body.appendChild(el)
	let t, ts = [], lb = el.firstChild, bqm = 0 //t:textarea or input, lb:language bar, bqm:backquote mode
	let pd = x => x.preventDefault()
	let ev = (x, t, f, c) => x.addEventListener(t, f, c)
	ev(lb, 'mousedown', x => {
		if (x.target.classList.contains('ngn_x')) { lb.hidden = 1; upd(); pd(x); return }
		if (x.target.nodeName === 'B' && t) {
			let i = t.selectionStart, j = t.selectionEnd, v = t.value, s = x.target.textContent
			if (i != null && j != null) { t.value = v.slice(0, i) + s + v.slice(j); t.selectionStart = t.selectionEnd = i + s.length }
			pd(x); return
		}
	})
	let fk = x => {
		let t = x.target
		if (bqm) {
			let i = t.selectionStart, v = t.value, c = bqc[x.key]; if (x.which > 31) { bqm = 0; d.body.classList.remove('ngn_bq') }
			if (c) { t.value = v.slice(0, i) + c + v.slice(i); t.selectionStart = t.selectionEnd = i + 1; pd(x); return !1 }
		}
		switch (x.ctrlKey + 2 * x.shiftKey + 4 * x.altKey + 8 * x.metaKey + 100 * x.which) {
			case 900: {
				let i = t.selectionStart, v = t.value, c = tc[v.slice(i - 2, i)] //tab
				if (c) { t.value = v.slice(0, i - 2) + c + v.slice(i); t.selectionStart = t.selectionEnd = i - 1; pd(x) }
				break
			}
		}
	}
	let ff = x => {
		let t0 = x.target, nn = t0.nodeName.toLowerCase()
		if (nn !== 'textarea' && (nn !== 'input' || t0.type !== 'text' && t0.type !== 'search')) return
		t = t0; if (!t.ngn) { t.ngn = 1; ts.push(t); ev(t, 'keydown', fk) }
	}
	let upd = _ => { d.body.style.marginTop = lb.clientHeight + 'px' }
	upd(); ev(window, 'resize', upd)
	ev(d, 'focus', ff, !0); let ae = d.activeElement; ae && ff({ type: 'focus', target: ae })
})();
